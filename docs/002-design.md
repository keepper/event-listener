# Проектирование системы событий

## Вступление

[Смотри](001-introduction.md) 

> Наилучший совет тем, кто приступает к проектированию системы, таков: не допускайте никаких допущений! 
> С самого начала нужно конкретизировать факты, известные об этой системе, и связанные с нею ожидания.

Поэтому начнем с описания границ 

## Контракт

ListenerManager - Объект который аккумулирует в себе слушателей событий.

Роль данного объекта сводится к следующиму:

1. Регистрация объекта слушателя события
1. Предоставление коллекции слушателей для конкретного события

### Регистрация объекта слушателя 

С учетом специфики описанного [подхода](001-introduction.md), минимально необходимое определение метода регистрации слушателя, должно выглядеть следующим образом.

```php
interface ListenerManagerInterface {

    /**
     * Добавляет слушателя, как екземпляр класса реализующего конкретный интерфейс "Слушателя события"
     * @param object $listener Cлушатель события
     */
    public function addListener(object $listener);
    
}
```

Почему object тип? В реализуемом подходе, все слушатель описываются с помощью интерфейса. Реализовывать интерфейс могут только объекты.

Отдельно существующего общего интерфейса слушателя, быть не может. Однако общая нотация типа **object** часто не совсем приемлема, в случае работы с большим проектом, ввиду того, что через чур общая.

В реальности, часто требуется быстро найти в проекте все классы или интерфейсы являющиеся "слушателями", что бывает сложно сделать, так как нет общего потомка. 

Для решение этой проблемы, заменим общий тип на "маркерный интерфейс". Маркерный интерфейс - это избыточный код, не несущий полезной программной нагрузки, при этом являющийся связующим звеном, для кода - в отдельной предметной области.

В нашем случае, это пустой интерфейс (без объявления методов), который должны наследовать все интерфейсы слушателей. В итоге, описание метода регистрации слушателя, преобразуем к следующему.

```php
interface ListenerManagerInterface {

    /**
     * Добавляет слушателя, как екземпляр класса реализующего конкретный интерфейс "Слушателя события"
     * @param ListenerInterface $listener Cлушатель события
     */
    public function addListener(ListenerInterface $listener);
    
}
```   

Стоит подумать над следующим вопросом. Стоит ли генерировать исключение, в случае когда, добавляется "Слушатель", 
о котором нам не известны "Мета" данные?

В существующих классических реализациях, при регистрации обработчика события, редко когда проверяется, наличие 
указанного события, в системе вообще. То есть, подписались мы на не существующее событие, значит просто наш слушатель 
никогда не будет вызван.

Является ли это проблемой? Одной из причин возникновения таких ситуаций - опечатка в имени события. В таком случае, нужно 
явно предупредить разработчика, что есть проблема. 

В нашем случае, возникновение ситуации когда добавляется слушатель, о котором не известны мета данные, означает нарушение цепочки 
связности при инициализации. Если модуль Б хочет добавить слушателя на событие от модуля А, то, при инициализации приложения, сначала, должен быть
инициализирован модуль А, который зарегистрирует мета данные своих событий, и потом уже инициализация моделя Б, который добавит слушателей.

В итоге, полезнее, генерировать исключение, а как его обрабатывать, вопрос реализации, на уровне приложения.

Исходя из выше сказанного, введем исключение **UnknownListenerException**.

```php
interface ListenerManagerInterface {
    
    /**
     * Добавляет слушателя, как екземпляр класса реализующего конкретный интерфейс "Слушателя события"
     * @param ListenerInterface $listener
     * @throws UnknownListenerException
     */
    public function addListener(ListenerInterface $listener): void;
    
}
```  

### Удаление ранее зарегистрированного объекта слушателя  

```php
interface ListenerManagerInterface {
    // ...
    
    /**
     * Удаляет слушателя. 
     * @throws UnregisteredListenerException - В случае если указанный слушатель, не был подписан
     */
    public function removeListener(ListenerInterface $listener): void;

    // ...
}
```

Также возникает вопрос: стоит ли генерировать исключение, в случае отписки не подписанного слушателя?

Остановимся на тех же логических выводах, что и при добавлении слушателя и добавим в нотацию метода исключение **UnregisteredListenerException**

### Получение коллекции слушателей по событию

Стоит отметить, что данные метод не стоит добавлять в сам интерфейс ListenerManagerInterface.
 
Основное предназначение: инжектирование в _EventDispatcher_ с ограничением области видимости только тех методов, которые достаточны для работы _EventDispatcher_.

На основе принципа [разделения интерфейсов](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF_%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0) выделим его в отдельный интерфейс
**ListenerProviderInterface**.   

Наш ListenerManagerInterface сделаем наследником данного интерфейса, так, как разделение их реализаций выглядит не как усложнение базовой архитектуры.

```php
interface ListenerManagerInterface extends ListenerProviderInterface {
    // ...
}
```

```php
interface ListenerProviderInterface {
    
    /**
     * Возвращает слушателей, для указанного события
     * @return callable[]
     */
    public function getListeners(string $eventId): array;
    
    /**
     * Возвращает признак наличия слушателей указанного события
     * @return bool
     */
    public function hasListeners(string $eventId): bool;
}
```

Почему тип string? Так как у нас нет понятие объект события, то единсвенное чем мы можем оперировать, это названием интерфейса описывающего слушателя. 

Выходит не красиво. Как альтернативный вариант, это введение понятия как имя события. 

В первом случае, имя уникально, но логически конструкция выглядит не корректной, так как для того, что бы сгенерировать событие, нам в _EventDispatcher_ придется передавать
название интерфейса слушателя.

Во втором случае, это ввод лишнего понятия, и проблемы с уникальностью самого имени события при импользовании в разных пакетах.

В любом из описанных случаев, типом является строка. Оставим, этот вопро на реализации, и зафиксируем в контракте тип и более размытое название eventId.

Почему возвращаемый тип callable. Так как данный метод предназначен в основном для использования его _EventDispatcher_ объектом, реализаций которого может быть множество, возвращаемый тип приведен к общепринятому для данного объекта.

Конвернтация типа из ListenerInterface в callable ложится на реализацию ListenerManagerInterface и в особености зависит, от выбранного в реализации способа
наполнения объекта мета данными о слушателях. 

### О наполнении ListenerManager мета данными

На данный момент, не совсем понятно, стоит ли описывать отдельным контрактом, методы наполнения объекта ListenerManger
мета данными, так как, это больше вопрос реализации.

Возможно стоит вернутся к этому вопросу позже.

### О контракте EventDispatcher

Так как предлагаемый подход, нарушает контракт стандарта [psr/event-dispatcher](https://www.php-fig.org/psr/psr-14/), 
на данный момент решено не покрывать EventDispatcher отдельным контрактом, и отдать это на уровень реализации.

## Реализация

Реализация описанных контрактов зависит от способов, которыми мы будем опрерировать для предоставлении объекту ListenerManager информации:
 
1. о именах интерфейсах слушателей
1. о именах методов для конвертации в callable тип.
1. о подходе к именованию события, которое должно передоваться в _EventDispatcher_

### Регистрация интерфейса слушателя

Это самый простой вопрос, нужно только передать в объект название интерфейса описывающего слушателя.

```php
class ListenerManager implements ListenerManagerInterface {
    // ..
    
    private $supportedInterfaceNames = [];
    
    public function addListenerInterface(string $interfaceName) {
        $this->supportedInterfaceNames[] = $interfaceName;
    }
    
    // ..
}
```

Это позволит, при добавлении слушателя, выяснить поддержку указанных интерфейсов

```php
class ListenerManager implements ListenerManagerInterface {
    // ..
    
    public function addListener(ListenerInterface $listener) {
        $hasKnowedInterface = false;
        
        foreach($this->supportedInterfaceNames as $interfaceName) {
            if ( $listener instanceof $interfaceName ) {
                $hasKnowedInterface = true;
            }
        }
        
        if ( !$hasKnowedInterface ) {
            throw new UnknownListenerException('Указанный слушатель, не реализует ни один из известных интерфейсов слушателей событий');
        }
        
        // ..
    }

    // ..
}
```

### Имя метода для конвертирования в callable 

В беглом анализе требования, можно его выполнить расширив метод **addListenerInterface**

```php
class ListenerManager implements ListenerManagerInterface {
    // ..
    
    public function addListenerInterface(string $interfaceName, string $mehtodName) {
        // ..
    }
    
    // ..
}
```

Этого уже достаточно, чтобы произвести конвертацию передаваемого в **addListener** экземпляра объекта в callable тип.

С другой стороны, если внимательно проанализировать, способы описания интерфейсов слушателей, мы получим выясним, что интерфейс слушателя, 
может содержать только описание одного метода, который и является вызываемым. 

Интерфейс, не может объявлять иные методы, так как, это передача контракта к реализации слушателя, с не понятными требованиями.

Исходя из этого, в момент регистрации интерфейса слушателя, мы может узнать имя единственного метода, серез Reflection, и мало, того при обнаружении
нескольких методов описаных в интерфейсе, сообщить об явно не корректном использовании контракта разработчику.

В этом случае минимально необходимая нотация будет иметь вид описаный ранее, без явной передачи имени метода.

### Идентификатор события

Как уже писалось ранее имеется несколько способов, через введение дополнительного понятия как "имя события", тогда раширением метода **addListenerInterface** мы решаем указаную проблему.

```php
class ListenerManager implements ListenerManagerInterface {
    // ..
    
    public function addListenerInterface(string $interfaceName, string $eventId) {
        // ..
    }
    
    // ..
}
```

Второй вариант, это использовать имя интерфейса события, в качестве идентификатора события. Но выглядит это не так красиво.

Хм. Выбор не очевидный. Какому варианту отдать предпочтение?

На данном этапе, реализации, я отдаю предпочтение варианту, для которого требуется знание только об имени интерфейса. Но вопрос, много граннен, и обсуждаем.